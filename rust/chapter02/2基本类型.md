## 数值类型

### 整数类型

|长度	 |有符号类型 |无符号类型 |
|--------|----------|----------|
|8 位	 |i8	    |u8        |
|16 位	 |i16	    |u16       |
|32 位	 |i32	    |u32       |
|64 位	 |i64	    |u64       |
|128 位	 |i128	    |u128      |
视架构而定|	isize	 |usize      |

要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：

    使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
    如果使用 checked_* 方法时发生溢出，则返回 None 值
    使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
    使用 saturating_* 方法使值达到最小值或最大值

### 浮点类型

浮点类型数字 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： f32 和 f64


对于数学上未定义的结果，例如对负数取平方根 -42.1.sqrt() ，会产生一个特殊的结果：Rust 的浮点数类型使用 NaN (not a number)来处理这些情况。

所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较，下面的代码会崩溃

```Rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```
出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN

```Rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```

### 序列(Range)

Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..=5，生成从 1 到 5 的连续数字，包含 5

序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型

```Rust
for i in 'a'..='z' {
    println!("{}",i);
}

```

## 语句与表达式

```Rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
```
语句(statement)没有返回值,表达式总要返回值

一旦你在表达式后加上分号，它就会变成一条语句，再也不会返回一个值，请牢记！

## 函数

```Rust
fn add(i: i32, j: i32) -> i32 {
   i + j
 }
```